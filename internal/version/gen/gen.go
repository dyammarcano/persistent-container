//go:build generate

package main

import (
	"crypto/sha256"
	"fmt"
	"github.com/caarlos0/log"
	"github.com/dyammarcano/base58"
	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/go-git/go-git/v5/plumbing/object"
	"os"
	"path/filepath"
	"text/template"
)

//go:generate go run gen.go

const templateVersionFile = `// Code generated by the go generate ./... command; DO NOT EDIT. 

package version

import "fmt"

var ver *Version

func init() {
	ver = &Version{
		Version:    "{{.Version}}",
		CommitHash: "{{.CommitHash}}",
		Date:       "{{.Date}}",
		Signature:  "{{.Signature}}",
	}
}

type Version struct {
	Version    string ` + "`json:\"version\"`" + `
	CommitHash string ` + "`json:\"commitHash\"`" + `
	Date       string ` + "`json:\"date\"`" + `
	Signature  string ` + "`json:\"signature\"`" + `
}

func GetVersion() *Version {
	return ver
}

func GetVersionString() string {
	return fmt.Sprintf("version: %s, commit: %s, date: %s, uuid: %s", ver.Version, ver.CommitHash, ver.Date, ver.Signature)
}
`

type Version struct {
	Version    string `json:"version"`
	CommitHash string `json:"commitHash"`
	Date       string `json:"date"`
	Signature  string `json:"signature"`
}

var repo *git.Repository

func init() {
	projectPath, err := filepath.Abs("../../../")
	checkErr(err)

	log.Infof("open git repository: %s", projectPath)

	repo, err = git.PlainOpen(projectPath) // open current dir
	checkErr(err)
}

func getCommit() (*object.Commit, error) {
	ref, err := repo.Head()
	if err != nil {
		return nil, err
	}

	commit, err := repo.CommitObject(ref.Hash())
	if err != nil {
		return nil, err
	}

	return commit, nil
}

func getCommitHash() (string, error) {
	commit, err := getCommit()
	if err != nil {
		return "", err
	}

	return commit.Hash.String(), nil
}

func getDate() (string, error) {
	commit, err := getCommit()
	if err != nil {
		return "", err
	}

	return commit.Author.When.Format("2006-01-02T15:04:05Z"), nil
}

func getTag() (string, error) {
	tags, err := repo.Tags()
	if err != nil {
		return "", err
	}

	var tag string
	callback := func(ref *plumbing.Reference) error {
		if ref.Name().IsTag() {
			tag = ref.Name().Short()
		}
		return nil
	}

	if err = tags.ForEach(callback); err != nil {
		return "", err
	}
	if err != nil {
		return "", err
	}

	return tag, nil
}

func sign(tag, commitHash, date string) string {
	h := sha256.New()
	h.Write([]byte(tag))
	h.Write([]byte(commitHash))
	h.Write([]byte(date))

	signDate := base58.StdEncoding.EncodeToString(h.Sum(nil))
	log.Infof("generate signature: %s", signDate)

	return signDate
}

// checkErr prints the msg with the prefix 'Error:' and exits with error code 1. If the msg is nil, it does nothing.
func checkErr(msg interface{}) {
	if msg != nil {
		fmt.Fprintln(os.Stderr, "Error:", msg)
		os.Exit(1)
	}
}

func main() {
	//change directory
	if err := os.Chdir(".."); err != nil {
		panic(err)
	}

	versionFile := "version.go"

	tmpl, err := template.New("versionFile").Parse(templateVersionFile)
	checkErr(err)

	file, err := os.Create(versionFile)
	checkErr(err)

	commitHash, err := getCommitHash()
	checkErr(err)

	date, err := getDate()
	checkErr(err)

	tag, err := getTag()
	checkErr(err)

	if tag == "" {
		tag = "v0.0.1-dev"
	}

	data := Version{
		Version:    tag,
		CommitHash: commitHash,
		Date:       date,
		Signature:  sign(tag, commitHash, date),
	}

	log.Infof("generating version file: %s", versionFile)

	err = tmpl.ExecuteTemplate(file, "versionFile", data)
	checkErr(err)
}
